---
marp: true
theme: default
paginate: true
incremental: true
header: "üìö Linguagens de Programa√ß√£o 1 | LEI, LEIRT, LIG"
footer: "![logo](./logo_lp1.png)![logo](./logo_lusofona.png)  Pedro Arroz Serra | pedro.serra@ulusofona.pt"
---


<style>
img[alt="logo"] {
  width: auto;  /* Adjust width */
  height: 25px; /* Keep aspect ratio */
  vertical-align: bottom; /* Align text with the image */
}
img[alt="pic_middle"] {
  width: auto;  /* Adjust width */
  height: 150px; /* Keep aspect ratio */
  vertical-align: middle; /* Align text with the image */
}
.grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
}

img[alt~="center"] {
  display: block;
  margin: 0 auto;
}
ul { list-style-type: none; padding-left: 0;}

</style>

# üì¢ Linguagens de Programa√ß√£o 1  

<div data-marpit-fragment>

```c
puts("\aAula #12");
```

</div>

---

# Conte√∫do

- Listas duplamente ligadas
- O pr√©-compilador
- Organizar o c√≥digo em m√∫ltiplos ficheiros

---

## Lista Duplamente Ligada

* Cada n√≥ tem um apontador para o pr√≥ximo e um apontador para o anterior

<div class='grid'>
  <div style="order: 1;">

<img src="lesson12_images/node_doubble.png" class="node-img">

</div>
  <div style="order: 2;">

~~~c
typedef struct _node {
  Item item;
  struct _node * next, * prev;
} node;
~~~

```c
typedef struct {
  char nome[100];
  enum {M,F,I} gender;
} pessoa;

typedef pessoa Item;
```


</div>
</div>

---
## Lista Duplamente Ligada

<div class='grid'>
  <div>

* C√≥digo para implementar a lista a colocar no ficheiro `list.h`

~~~c
#include "Item.h"

typedef struct _node {
  Item item;
  struct _node * next, * prev;
} node;
~~~

</div>
<div>

* C√≥digo que trata o "payload" a colocar no ficheiro `Item.h`
```c
typedef struct {
  char nome[100];
  enum {M,F,I} gender;
} pessoa;

typedef pessoa Item;
```



</div>
</div>

---

## Lista simplesmente ligada com *head e tail pointer*

![w:800 center](lesson12_images/double_linked_list.png)


<div class='grid'>
  <div>

~~~c
#include "Item.h"

typedef struct _node {
  Item item;
  struct _node * next, * prev;
} node;

typedef struct {
  node * head;
  node * tail;
} List;
~~~


</div>
<div>

- C√≥digo no ficheiro `list.h`


- Podemos definir uma estrutura nova (`List`) que serve para guardar o apontador para o `head` e o apontador para o `tail`

</div>
</div>


---

# Inicializar

<div class='grid'>
  <div>

* ficheiro `list.c`:

~~~c
List * ListNew(void) {
  List * L  = (List *) malloc(sizeof(*L));
  L -> head = L -> tail = NULL;
  return L;
}
~~~


</div>
<div>

* ficheiro `main.c`

~~~c
int main() {
  List *L = ListNew();
  ...
}
~~~

</div>
</div>


---

## Inserir no fim da lista


<div class='grid'>
  <div>

<small>

```c
node * NodeNew(Item i) {
  node * new = (node *) malloc (sizeof(node));
  if (new == NULL) exit(1); // out of memory
  new -> item = i;
  new -> next = n -> prev = NULL;
  return new;
}

void ListInsertEnd(List * L, Item i) {  
  node * new = NodeNew(i);
  if (ListEmpty(L))
    L -> tail = L -> head = new;
  else {
    L -> tail -> next = new;
    new -> prev = L -> tail;
    L -> tail = new;
  }
}

int ListEmpty(List *L) {
  return L->head == NULL;
}
```

</small>

</div>
<div>

* ficheiro `main.c`
~~~c
int main() {
  List *L = ListNew();
  Item p = {"Marcella", F};

  ListInsertEnd(L, p);

  ...
}

~~~

</div>
</div>

---

## Inserir no in√≠cio da lista

<div class='grid'>
  <div>


```c
void ListInsertTop(List * L, Item i)
{
  node * new = NodeNew(i);

  if (ListEmpty(L)) {
    L -> tail = L -> head = new;
    return;
  }
  
  new -> next = L -> head;
  L -> head -> prev = new;
  L -> head = new;
}
```

</div>
<div>

* ficheiro `main.c`
~~~c
int main() {
  List *L = ListNew();
  Item p = {"Marcella", F};

  ListInsertTop(L, p);

  ...
}

~~~

</div>
</div>

---


# Remover o primeiro elemento

<div class='grid'>
  <div>

```c
// esta funcao nao pode ser chamada se
// a lista estiver vazia
Item ListRemoveTop(List * L)
{
  Item i;
  node * t;

  if (ListEmpty(L)) exit(0);

  i = L -> head -> item;
  // auxiliar que guarda o head que vamos eliminar
  t = L -> head;
  L -> head = L -> head -> next;
  free(t);
  
  // se a lista ficou vazia,
  // temos que actualizar o tail
  if (ListEmpty(L))
    L -> tail = NULL;
  else
    // caso contr√°rio temos que actualizar o prev
    L -> head -> prev = NULL;

  return i;
}
```

</div>
<div>

* ficheiro `main.c`
~~~c
int main() {
  List *L = ListNew();
  Item p = {"Marcella", F};
  Item i;

  ListInsertTop(L, p);

  if (!ListEmpty(L))
    i = ListRemoveTop(L);
  ...
}
~~~

</div>
</div>

---

## Remover o √∫ltimo elemento

<div class='grid'>
  <div>

```c
// esta funcao nao pode ser chamada se
// a lista estiver vazia
Item ListRemoveEnd(List * L)
{
  Item i;
  node * t, * aux;

  if (ListEmpty(L)) exit(1);

  i = L -> tail -> item;
  t = L -> tail;

  // se a lista s√≥ tinha um elemento,
  // ficar√° vazia e temos que actualizar o head
  if (t == L -> head)
    L -> head = L -> tail = NULL;
  else {
    // actualizar o penultimo
    t -> prev -> next = NULL;
    L -> tail = t -> prev;
  }

  free(t);
  return i;
}
```

</div>
<div>

* ficheiro `main.c`
~~~c
int main() {
  List *L = ListNew();
  Item p = {"Marcella", F};
  Item i;

  ListInsertTop(L, p);

  if (!ListEmpty(L))
    i = ListRemoveEnd(L);
  ...
}
~~~

</div>
</div>

---

## Imprimir todos os elementos

~~~c
void ItemPrint(Item i) {
  char enum2char[] = {'M', 'F', 'I'};
  printf("%s - (%c)\n", i.nome, enum2char[i.gender]);
}

int main() {
  List *L = ListNew();
  Item a = {"Marcella", F}, b = {"Mariah", F}, c = {"Manu", F};
  node * t;

  ListInsertTop(L, a);
  ListInsertTop(L, b);
  ListInsertEnd(L, c);

  for(t = L->head; t != NULL ; t = t -> next)
    ItemPrint(t -> item);
}
~~~

---

# Recapitulando üìå

| Opera√ß√£o | Fun√ß√£o usada     | Complexidade |
|----------|------------------|--------------|
| Inserir  | `ListInsertTop()`      | O(1)         |
| Inserir  | `ListInsertEnd()`      | O(1)         |
| Remover  | `ListRemoveTop()`      | O(1)         |
| Remover  | `ListRemoveEnd()`      | O(1)        |
| Listar   | `ListPrint()`       | O(n)         |

---

# Recursividade

---

# Contagem decrescente sem ciclo üßÆ

Como escrever uma fun√ß√£o que conte de `n` at√© `0` sem usar `for` ou `while`?


<div class='grid'>
  <div>

## Vers√£o com ciclo:

~~~c
void count_down(unsigned int n) {
    for (int i = n; i >= 0; i--)
        printf("%d\n", i);
}
~~~

</div>
<div>

## Vers√£o recursiva üîÇ

~~~c
void count_down(unsigned int n) {
    printf("%d\n", n);
    if (n > 0)
        count_down(n - 1);
}
~~~

üß† A fun√ß√£o chama-se a si pr√≥pria com um valor mais pequeno  
‚û°Ô∏è At√© chegar ao caso base (`n == 0`)

</div>
</div>


---

# O que √© recursividade? ü§î

üìå Recursividade √© a **capacidade de uma fun√ß√£o se invocar a si pr√≥pria**

üîÅ Cada chamada √© empilhada na **stack (pilha)**  
üß† √ötil quando o problema pode ser dividido em subproblemas mais simples

---

# Recursividade vs Itera√ß√£o ‚öîÔ∏è

| Recursiva                   | Iterativa                     |
|----------------------------|-------------------------------|
| C√≥digo mais compacto       | Pode ser mais eficiente       |
| Mais mem√≥ria (stack) usada | Menos mem√≥ria usada           |
| Elegante para certos casos | Boa para grandes entradas     |
| Necessita de caso base     | Usa ciclo `for` ou `while`    |

---

# Exemplo: Fatorial de `n` üéØ

~~~c
int factorial(int n) {
    if (n > 1)
        return n * factorial(n - 1);
    return 1;
}
~~~

üß† f(4) ‚Üí 4 √ó f(3) ‚Üí 4 √ó 3 √ó f(2) ‚Üí 4 √ó 3 √ó 2 √ó f(1) ‚Üí ...

---

# O que acontece na mem√≥ria? üß†

Cada chamada guarda:
- Vari√°veis locais
- Estado de execu√ß√£o

üì¶ Tudo isso √© armazenado na **stack**

‚õî Demasiadas chamadas ‚Üí `stack overflow`

---

# Exemplo passo-a-passo

~~~c
int fact(int n) {
    int r;
    if (n > 1)
        r = n * fact(n - 1);
    else
        r = 1;
    return r;
}
int main() {
    int n = fact(4);
    return 0;
}
~~~

---

## ‚ùì  Quizz - Recursividade

<br>

![w:200 center](socrative.png)


<br>


- No campo nome devem colocar o **n√∫mero de aluno** 2XXXXXXX.


---

# Quiz 1 ü§ì

Determine o valor final de `res`:

~~~c
int pw(int x, int n) {
    if (n == 0) return 1;
    return x * pw(x, n - 1);
}
int main() {
    int res = pw(2, 4);
    return 0;
}
~~~

‚úçÔ∏è **Resposta**: 2‚Å¥ = **16**

---

## ‚ùì  Quizz - Recursividade 2

<br>

![w:200 center](socrative.png)


<br>


- No campo nome devem colocar o **n√∫mero de aluno** 2XXXXXXX.



---
# Quiz 2 ü§ì

Determine o valor de `res`:

~~~c
int rec(int n) {
    if (n > 0) return n + rec(n - 1);
    return -1;
}
int main() {
    int res = rec(4);
    return 0;
}
~~~

‚úçÔ∏è **Resposta**: 4 + 3 + 2 + 1 + 0 + (-1) = **9**

---

# Regras da recursividade üìè

Para escrever uma fun√ß√£o recursiva:

‚úÖ **Caso base** ‚Äî onde a fun√ß√£o termina  
üîÅ **Chamada recursiva** ‚Äî aproxima-se do caso base

---

# Soma recursiva üß†

<div class='grid'>
  <div>

~~~c
int sum(int n) {
    if (n == 0) return 0;
    return n + sum(n - 1);
}
~~~

Vers√£o iterativa:

~~~c
int sum(int n) {
    int soma = 0;
    for (int i = 0; i <= n; i++)
        soma += i;
    return soma;
}
~~~

</div>
<div>

# Visualiza√ß√£o da stack üß±

Para `sum(2)`:

```
sum(2)
 ‚Ü≥ 2 + sum(1)
       ‚Ü≥ 1 + sum(0)
             ‚Ü≥ 0
```

Resultado final: 2 + 1 + 0 = **3**

</div>
</div>

---

# Invers√£o com recursividade üîÅ

~~~c
void inv() {
    char c = getchar();
    if (c != '\n') {
        inv();
        putchar(c);
    }
}
~~~

üß† A string √© lida e **reimpressa ao contr√°rio**, como numa pilha!

---

# Exemplo: Mudan√ßa de base üî¢

Converte um n√∫mero de base 10 para base N:

~~~c
const char symbols[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

void muda_base(unsigned int val, unsigned int base) {
    int resto = val % base;
    val = val / base;
    if (val > 0)
        muda_base(val, base);
    printf("%c", symbols[resto]);
}
~~~

---

# Exerc√≠cio 1 üìö

Implemente uma fun√ß√£o que devolva o 10¬∫ n√∫mero da sequ√™ncia de Fibonacci:

1, 1, 2, 3, 5, 8, 13, 21, 34, 55...

**Dica**: cada n√∫mero √© a soma dos dois anteriores.

---

# Solu√ß√£o recursiva üîÅ

~~~c
int fib(int n) {
    if (n <= 2) return 1;
    return fib(n - 2) + fib(n - 1);
}

int main() {
    printf("fib(10) = %d\n", fib(10)); // 55
    return 0;
}
~~~

---

# Solu√ß√£o iterativa üîÉ

~~~c
int fib(int n) {
    int penultimo = 1, ultimo = 1, soma = 0;
    if (n <= 2) return 1;

    for (int i = 3; i <= n; i++) {
        soma = penultimo + ultimo;
        penultimo = ultimo;
        ultimo = soma;
    }

    return ultimo;
}
~~~

---

# Conclus√£o ‚ú®

‚úÖ Recursividade √© poderosa mas deve ser usada com cuidado  
‚úÖ Exige sempre um **caso base**  
‚úÖ √ötil para problemas naturalmente recursivos (√°rvores, pilhas, divis√µes)  
‚úÖ Itera√ß√µes s√£o geralmente mais eficientes, mas menos elegantes

---


# O Pr√©-Processador üõ†Ô∏è

---

# O Pr√©-Processador em C üõ†Ô∏è

Antes de compilar o c√≥digo, o **pr√©-processador** realiza v√°rias transforma√ß√µes:
- Inclui ficheiros
- Substitui macros
- Condiciona blocos de c√≥digo

Estas transforma√ß√µes **n√£o s√£o C**, mas instru√ß√µes para o pr√©-processador!

---

# Diretivas mais comuns üìã

| Diretiva      | Fun√ß√£o                                 |
|---------------|-----------------------------------------|
| `#include`    | Insere o conte√∫do de outro ficheiro     |
| `#define`     | Define uma macro                        |
| `#undef`      | Anula uma macro                         |
| `#ifdef`      | Se a macro estiver definida             |
| `#ifndef`     | Se a macro **n√£o** estiver definida     |
| `#endif`      | Fecha `#if`, `#ifdef`, `#ifndef`        |

---

# Exemplo com `#include` üì•

~~~c
#include <stdio.h>   // Biblioteca do sistema
#include "minha.h"   // Ficheiro criado por n√≥s
~~~

- Aspas `"` ‚Üí procura no diret√≥rio atual
- Sinais `<>` ‚Üí procura nas bibliotecas do sistema

---

# Evitar inclus√µes duplicadas üîÅ

Usamos **guardas de inclus√£o**:

~~~c
#ifndef __MINHA_H__
#define __MINHA_H__

// conte√∫do do header

#endif
~~~

‚úÖ Garante que o c√≥digo s√≥ √© inclu√≠do **uma vez**, mesmo que `#include` seja repetido

---

# Organizar c√≥digo em v√°rios ficheiros üß©

Separar o c√≥digo ajuda a:
- Reutilizar fun√ß√µes
- Dividir responsabilidades
- Compilar partes separadas

---

# Organiza√ß√£o t√≠pica de ficheiros üìÅ

```
main.c         ‚Üí fun√ß√£o principal
funcoes.h      ‚Üí declara√ß√µes de fun√ß√µes
funcoes.c      ‚Üí implementa√ß√µes das fun√ß√µes
```

---


<div class='grid'>
<div>

## Exemplo `funcoes.h` üìò

~~~c
#ifndef FUNCOES_H
#define FUNCOES_H

void ola();
int soma(int a, int b);

#endif
~~~


</div>
<div>

## Exemplo `funcoes.c` ‚öôÔ∏è

~~~c
#include <stdio.h>
#include "funcoes.h"

void ola() {
    printf("Ol√° mundo!\n");
}

int soma(int a, int b) {
    return a + b;
}
~~~

</div>
</div>

---

# Exemplo `main.c` üß†

~~~c
#include <stdio.h>
#include "funcoes.h"

int main() {
    ola();
    printf("3 + 4 = %d\n", soma(3, 4));
    return 0;
}
~~~

---

## Compilar v√°rios ficheiros üß±

<div class='grid'>
<div>

- Ficheiros na directoria do projecto

```
programa
    +-- funcoes.h
    +-- funcoes.c
    +-- main.c
```


</div>
<div>

Usar o `gcc` com todos os `.c`:

```bash
gcc main.c funcoes.c -o programa
```

üéØ Compila e junta tudo num √∫nico execut√°vel





</div>
</div>


* podemos incluir as flags opcionais

```bash
gcc main.c funcoes.c -o programa -g -Wvla -Wall -Wpedantic -Wextra -Wdeclaration-after-statement -lm
```

---

## Compila√ß√£o em duas fases ‚öôÔ∏è‚û°Ô∏èüîó

1. Compilar separadamente:
```bash
gcc -c funcoes.c -o funcoes.o -g -Wvla -Wall ...
gcc -c main.c -o main.o -g -Wvla -Wall ...
```

2. Ligar (linkar):
```bash
gcc main.o funcoes.o -o programa -lm
```

üí° Permite recompilar apenas ficheiros modificados

---

# Makefile (b√≥nus) üß©

Um `Makefile` automatiza a compila√ß√£o:

~~~make
programa: main.o funcoes.o
	gcc main.o funcoes.o -o programa

main.o: main.c funcoes.h
	gcc -c main.c

funcoes.o: funcoes.c funcoes.h
	gcc -c funcoes.c

clean:
	rm -f *.o programa
~~~

üîÅ Usa `make` para compilar tudo, e `make clean` para limpar

---

# Exerc√≠cio üß™

<div class='grid'>
<div>

1. Cria os ficheiros:
   - `main.c`
   - `matematica.c`
   - `matematica.h`

2. Em `matematica.h`, declara:
   - `int quadrado(int x);`

</div>
<div>

3. Em `matematica.c`, implementa a fun√ß√£o:
   - retorna o quadrado de um n√∫mero

4. Em `main.c`, usa a fun√ß√£o com `printf`

5. Compila e testa!

</div>
</div>

---

# Conclus√£o üì¶

‚úÖ O pr√©-processador √© essencial no pipeline de compila√ß√£o  
‚úÖ Permite usar macros, condicionar c√≥digo e importar headers  
‚úÖ Organizar c√≥digo em v√°rios ficheiros melhora a clareza e manuten√ß√£o  
‚úÖ Usa `make` para automatizar tudo üîÑ

---

# ‚ùì Q&A  

üí¨ **D√∫vidas?**  
